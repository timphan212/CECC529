/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package federalistpapersengine;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.GridLayout;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JFileChooser;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTable;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;
import javax.swing.table.DefaultTableModel;
/**
 *
 * @author Tim
 */
public class FederalistPapersGUI extends javax.swing.JFrame {

    /**
     * Creates new form FederalistPapersGUI
     */
    public FederalistPapersGUI() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        directoryChooser = new javax.swing.JFileChooser();
        mainPanel = new javax.swing.JPanel();
        hamiltonPanel = new javax.swing.JPanel();
        hamiltonScrollPane = new javax.swing.JScrollPane();
        hamiltonTable = new javax.swing.JTable();
        madisonPanel = new javax.swing.JPanel();
        madisonScrollPane = new javax.swing.JScrollPane();
        madisonTable = new javax.swing.JTable();
        jayPanel = new javax.swing.JPanel();
        jayScrollPane = new javax.swing.JScrollPane();
        jayTable = new javax.swing.JTable();
        rocchioButton = new javax.swing.JButton();
        bayesianButton = new javax.swing.JButton();
        hamiltonLabel = new javax.swing.JLabel();
        madisonLabel = new javax.swing.JLabel();
        jayLabel = new javax.swing.JLabel();
        hamiltonFileLabel = new javax.swing.JLabel();
        madisonFileLabel = new javax.swing.JLabel();
        jayFileLabel = new javax.swing.JLabel();
        fileMenuBar = new javax.swing.JMenuBar();
        fileMenu = new javax.swing.JMenu();
        openMenuItem = new javax.swing.JMenuItem();
        openExistingMenuItem = new javax.swing.JMenuItem();

        directoryChooser.setFileSelectionMode(javax.swing.JFileChooser.DIRECTORIES_ONLY);

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Who Wrote the Federalist Papers?");
        getContentPane().setLayout(new java.awt.GridLayout(1, 0));

        hamiltonTable.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {

            },
            new String [] {
                "Papers"
            }
        ) {
            Class[] types = new Class [] {
                java.lang.String.class
            };
            boolean[] canEdit = new boolean [] {
                false
            };

            public Class getColumnClass(int columnIndex) {
                return types [columnIndex];
            }

            public boolean isCellEditable(int rowIndex, int columnIndex) {
                return canEdit [columnIndex];
            }
        });
        hamiltonTable.getSelectionModel().addListSelectionListener(new
            ListSelectionListener() {
                @Override
                public void valueChanged(ListSelectionEvent e) {
                    int row = hamiltonTable.getSelectedRow();

                    if(row >= 0 && !e.getValueIsAdjusting() && !hamiltonTable.getSelectionModel()
                        .isSelectionEmpty()) {
                        String file = hamiltonTable.getValueAt(row, 0).toString();

                        if(file.endsWith(".txt")) {
                            openFile(file);
                        }
                    }
                }
            });
            hamiltonScrollPane.setViewportView(hamiltonTable);

            javax.swing.GroupLayout hamiltonPanelLayout = new javax.swing.GroupLayout(hamiltonPanel);
            hamiltonPanel.setLayout(hamiltonPanelLayout);
            hamiltonPanelLayout.setHorizontalGroup(
                hamiltonPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addComponent(hamiltonScrollPane, javax.swing.GroupLayout.PREFERRED_SIZE, 175, javax.swing.GroupLayout.PREFERRED_SIZE)
            );
            hamiltonPanelLayout.setVerticalGroup(
                hamiltonPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addComponent(hamiltonScrollPane, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
            );

            madisonTable.setModel(new javax.swing.table.DefaultTableModel(
                new Object [][] {

                },
                new String [] {
                    "Papers"
                }
            ) {
                Class[] types = new Class [] {
                    java.lang.String.class
                };
                boolean[] canEdit = new boolean [] {
                    false
                };

                public Class getColumnClass(int columnIndex) {
                    return types [columnIndex];
                }

                public boolean isCellEditable(int rowIndex, int columnIndex) {
                    return canEdit [columnIndex];
                }
            });
            madisonTable.getSelectionModel().addListSelectionListener(new
                ListSelectionListener() {
                    @Override
                    public void valueChanged(ListSelectionEvent e) {
                        int row = madisonTable.getSelectedRow();

                        if(row >= 0 && !e.getValueIsAdjusting() && !madisonTable.getSelectionModel()
                            .isSelectionEmpty()) {
                            String file = madisonTable.getValueAt(row, 0).toString();

                            if(file.endsWith(".txt")) {
                                openFile(file);
                            }
                        }
                    }
                });
                madisonScrollPane.setViewportView(madisonTable);

                javax.swing.GroupLayout madisonPanelLayout = new javax.swing.GroupLayout(madisonPanel);
                madisonPanel.setLayout(madisonPanelLayout);
                madisonPanelLayout.setHorizontalGroup(
                    madisonPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(madisonScrollPane, javax.swing.GroupLayout.PREFERRED_SIZE, 175, javax.swing.GroupLayout.PREFERRED_SIZE)
                );
                madisonPanelLayout.setVerticalGroup(
                    madisonPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(madisonScrollPane, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                );

                jayTable.setModel(new javax.swing.table.DefaultTableModel(
                    new Object [][] {

                    },
                    new String [] {
                        "Papers"
                    }
                ) {
                    Class[] types = new Class [] {
                        java.lang.String.class
                    };
                    boolean[] canEdit = new boolean [] {
                        false
                    };

                    public Class getColumnClass(int columnIndex) {
                        return types [columnIndex];
                    }

                    public boolean isCellEditable(int rowIndex, int columnIndex) {
                        return canEdit [columnIndex];
                    }
                });
                jayTable.getSelectionModel().addListSelectionListener(new
                    ListSelectionListener() {
                        @Override
                        public void valueChanged(ListSelectionEvent e) {
                            int row = jayTable.getSelectedRow();

                            if(row >= 0 && !e.getValueIsAdjusting() && !jayTable.getSelectionModel()
                                .isSelectionEmpty()) {
                                String file = jayTable.getValueAt(row, 0).toString();

                                if(file.endsWith(".txt")) {
                                    openFile(file);
                                }
                            }
                        }
                    });
                    jayScrollPane.setViewportView(jayTable);

                    javax.swing.GroupLayout jayPanelLayout = new javax.swing.GroupLayout(jayPanel);
                    jayPanel.setLayout(jayPanelLayout);
                    jayPanelLayout.setHorizontalGroup(
                        jayPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                        .addComponent(jayScrollPane, javax.swing.GroupLayout.DEFAULT_SIZE, 175, Short.MAX_VALUE)
                    );
                    jayPanelLayout.setVerticalGroup(
                        jayPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                        .addComponent(jayScrollPane)
                    );

                    rocchioButton.setText("Rocchio Classification");
                    rocchioButton.addActionListener(new java.awt.event.ActionListener() {
                        public void actionPerformed(java.awt.event.ActionEvent evt) {
                            rocchioButtonActionPerformed(evt);
                        }
                    });

                    bayesianButton.setText("Bayesian Classification");
                    bayesianButton.addActionListener(new java.awt.event.ActionListener() {
                        public void actionPerformed(java.awt.event.ActionEvent evt) {
                            bayesianButtonActionPerformed(evt);
                        }
                    });

                    hamiltonLabel.setText("Hamilton:");

                    madisonLabel.setText("Madison:");

                    jayLabel.setText("Jay:");

                    hamiltonFileLabel.setText("Documents found: ");

                    madisonFileLabel.setText("Documents found:");

                    jayFileLabel.setText("Documents found:");

                    javax.swing.GroupLayout mainPanelLayout = new javax.swing.GroupLayout(mainPanel);
                    mainPanel.setLayout(mainPanelLayout);
                    mainPanelLayout.setHorizontalGroup(
                        mainPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                        .addGroup(mainPanelLayout.createSequentialGroup()
                            .addGroup(mainPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                .addGroup(mainPanelLayout.createSequentialGroup()
                                    .addContainerGap()
                                    .addGroup(mainPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                        .addComponent(hamiltonLabel)
                                        .addComponent(hamiltonPanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                        .addComponent(hamiltonFileLabel))
                                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                    .addGroup(mainPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                        .addComponent(madisonLabel)
                                        .addComponent(madisonPanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                        .addComponent(madisonFileLabel))
                                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                    .addGroup(mainPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                        .addComponent(jayFileLabel)
                                        .addComponent(jayLabel)
                                        .addComponent(jayPanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))
                                .addGroup(mainPanelLayout.createSequentialGroup()
                                    .addGap(125, 125, 125)
                                    .addComponent(rocchioButton)
                                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                    .addComponent(bayesianButton)))
                            .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                    );
                    mainPanelLayout.setVerticalGroup(
                        mainPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                        .addGroup(mainPanelLayout.createSequentialGroup()
                            .addGap(12, 12, 12)
                            .addGroup(mainPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                                .addComponent(hamiltonLabel)
                                .addGroup(mainPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                    .addComponent(madisonLabel)
                                    .addComponent(jayLabel)))
                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                            .addGroup(mainPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                                .addComponent(madisonPanel, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                .addComponent(hamiltonPanel, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                .addComponent(jayPanel, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                            .addGroup(mainPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                .addComponent(hamiltonFileLabel)
                                .addComponent(madisonFileLabel)
                                .addComponent(jayFileLabel))
                            .addGap(18, 18, 18)
                            .addGroup(mainPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                .addComponent(rocchioButton)
                                .addComponent(bayesianButton))
                            .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                    );

                    getContentPane().add(mainPanel);

                    fileMenu.setText("File");

                    openMenuItem.setText("Open Directory");
                    openMenuItem.addActionListener(new java.awt.event.ActionListener() {
                        public void actionPerformed(java.awt.event.ActionEvent evt) {
                            openMenuItemActionPerformed(evt);
                        }
                    });
                    fileMenu.add(openMenuItem);

                    openExistingMenuItem.setText("Open Existing Files");
                    openExistingMenuItem.addActionListener(new java.awt.event.ActionListener() {
                        public void actionPerformed(java.awt.event.ActionEvent evt) {
                            openExistingMenuItemActionPerformed(evt);
                        }
                    });
                    fileMenu.add(openExistingMenuItem);

                    fileMenuBar.add(fileMenu);

                    setJMenuBar(fileMenuBar);

                    pack();
                }// </editor-fold>//GEN-END:initComponents

    private void openMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_openMenuItemActionPerformed
        if (directoryChooser.showOpenDialog(this) == JFileChooser.APPROVE_OPTION) {
            try {
                DirectoryIndex index = new DirectoryIndex();
                String currentDir = directoryChooser.getSelectedFile()
                        .toString();
                index.buildIndexForDirectory(currentDir);
                dindex = new DiskInvertedIndex(currentDir);
                initializeClasses(currentDir);
                
                JOptionPane.showMessageDialog(this, "Successfully indexed "
                        + currentDir + " files.", "Indexed",
                        JOptionPane.INFORMATION_MESSAGE);
            } catch (IOException ex) {
                Logger.getLogger(FederalistPapersGUI.class.getName()).log(Level.SEVERE, null, ex);
            }
        } 
    }//GEN-LAST:event_openMenuItemActionPerformed

    private void rocchioButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_rocchioButtonActionPerformed
        if (dindex == null) {
            JOptionPane.showMessageDialog(this, "Index is null."
                    , "Index error!", JOptionPane.ERROR);
        }
        else {
            double[] hCentroid = hDocs.getCentroid();
            double[] mCentroid = mDocs.getCentroid();
            double[] jCentroid = jDocs.getCentroid();
            ArrayList<Integer> hDocList = new ArrayList<>();
            hDocList.addAll(hDocs.getFiles());
            ArrayList<Integer> mDocList = new ArrayList<>();
            mDocList.addAll(mDocs.getFiles());
            ArrayList<Integer> jDocList = new ArrayList<>();
            jDocList.addAll(jDocs.getFiles());
            String results = "";
            
            for(int doc : disputedDocs) {
                double[] docVector = documentVectors.get(doc);
                double hResults = calculateClosestCentroid(hCentroid, docVector);
                double mResults = calculateClosestCentroid(mCentroid, docVector);
                double jResults = calculateClosestCentroid(jCentroid, docVector);
                results += String.format("%s> h: %.5f    m: %.5f    j: %.5f\n",
                        dindex.getFileNames(doc), hResults, mResults, jResults);
                
               if(hResults < mResults) {
                    if(hResults < jResults) {
                        hDocList.add(doc);
                    }
                }
                else {
                    if(mResults < jResults) {
                        mDocList.add(doc);
                    }
                    else {
                        jDocList.add(doc);
                    }
                }
            }
            
            JOptionPane.showMessageDialog(this, results, "Rocchio Results",
                    JOptionPane.INFORMATION_MESSAGE);
            displayFiles(hamiltonTable, hDocList, hamiltonFileLabel);
            displayFiles(madisonTable, mDocList, madisonFileLabel);
            displayFiles(jayTable, jDocList, jayFileLabel);
        }
    }//GEN-LAST:event_rocchioButtonActionPerformed

    private void bayesianButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_bayesianButtonActionPerformed
        if (dindex == null) {
            JOptionPane.showMessageDialog(this, "Index is null."
                    , "Index error!", JOptionPane.ERROR);
        }
        else {
            getMutualInfoScores();
            getEvidenceVector();
            selectEvidence();
            getFrequencyTerms();
            trainBayesianClassifier();
            
            ArrayList<Double> ptch = hDocs.getPtch();
            ArrayList<Double> ptcj = jDocs.getPtcj();
            ArrayList<Double> ptcm = mDocs.getPtcm();

            int fileCount = dindex.getDocumentCount();

            for(int file : disputedDocs) {
                double hSum = 0.0, mSum = 0.0, jSum = 0.0;
                ArrayList<String> terms = disputedDocsMap.get(file);
 
                for(String term : terms) {
                    int index = disputedDocsTerms.indexOf(term);
                    hSum += Math.log(ptch.get(index));
                    mSum += Math.log(ptcm.get(index));
                    jSum += Math.log(ptcj.get(index));
                }               
                
                hSum += Math.log((double)hDocs.getFiles().size()/fileCount);
                mSum += Math.log((double)mDocs.getFiles().size()/fileCount);
                jSum += Math.log((double)jDocs.getFiles().size()/fileCount);
                
                System.out.println("h: " + hSum + " m: " + mSum + " j: " + jSum);
            }
        }
    }//GEN-LAST:event_bayesianButtonActionPerformed

    private void openExistingMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_openExistingMenuItemActionPerformed
        if (directoryChooser.showOpenDialog(this) == JFileChooser.APPROVE_OPTION) {
            try {
                String currentDir = directoryChooser.getSelectedFile()
                        .toString();
                dindex = new DiskInvertedIndex(currentDir);
                initializeClasses(currentDir);

                JOptionPane.showMessageDialog(this, "Successfully indexed "
                        + currentDir + " files.", "Indexed",
                        JOptionPane.INFORMATION_MESSAGE);
            } catch (IOException ex) {
                Logger.getLogger(FederalistPapersGUI.class.getName()).log(Level.SEVERE, null, ex);
            }
        } 
    }//GEN-LAST:event_openExistingMenuItemActionPerformed

    /**
     * When a user clicks on the file it opens a new window containing the
     * contents of the file
     *
     * @param file
     */
    private void openFile(String file) {
        JFrame frame = new JFrame(file);
        frame.setMinimumSize(new Dimension(800, 600));
        JPanel panel = new JPanel();
        panel.setLayout(new GridLayout(1, 0));
        JLabel label = new JLabel();
        panel.setBackground(Color.WHITE);
        String folder = getFolder(file);
        
        try {
            BufferedReader br = new BufferedReader(new FileReader(folder));
            String line;
            StringBuilder sb = new StringBuilder();
            
            while((line = br.readLine()) != null) {
                sb.append(line);
                sb.append(System.lineSeparator());
            }

            label.setText("<html><div WIDTH=600px>" + sb.toString() 
                    + "</div><html>");
        } catch (IOException ex) {
            Logger.getLogger(FederalistPapersGUI.class.getName())
                    .log(Level.SEVERE, null, ex);
        }

        label.setHorizontalAlignment(JLabel.LEFT);
        label.setVerticalAlignment(JLabel.NORTH);
        panel.add(label);
        JScrollPane scrollBar = new JScrollPane(panel);
        frame.add(scrollBar);
        frame.pack();
        frame.setVisible(true);
    }
    
    /**
     * Returns a folder path of where the file is located
     * @param file name of file
     * @return 
     */
    private String getFolder(String file) {
        String path = directoryChooser.getSelectedFile().getAbsolutePath();
        int num = Integer.parseInt(file.substring(6, 8));

        if((num >= 49 && num <= 57) || num == 62 || num == 63) {
            return path + "\\HAMILTON OR MADISON\\" + file;
        }
        else {
            return path + "\\ALL\\" + file;
        }
    }
    
    /**
     * Create the document vectors based on the index then calculate the
     * centroid for each class
     * @param path string value representing the path to the folders
     */
    private void initializeClasses(String path) {
        try {
            ArrayList<String> files;
            ArrayList<Integer> docIDs;
            
            initializeDocumentVectors();
            
            files = DiskInvertedIndex.readAllFileNames(path + "\\JAY");
            docIDs = getDocIdList(files);
            jDocs = new JayDocuments(docIDs);
            jDocs.setCentroid(calculateCentroid(jDocs.getFiles()));
            
            files = DiskInvertedIndex.readAllFileNames(path + "\\MADISON");
            docIDs = getDocIdList(files);
            mDocs = new MadisonDocuments(docIDs);
            mDocs.setCentroid(calculateCentroid(mDocs.getFiles()));
            
            files = DiskInvertedIndex.readAllFileNames(path + "\\HAMILTON");
            docIDs = getDocIdList(files);
            hDocs = new HamiltonDocuments(docIDs);
            hDocs.setCentroid(calculateCentroid(hDocs.getFiles()));
            
            files = DiskInvertedIndex.readAllFileNames(path + "\\HAMILTON OR MADISON");
            disputedDocs = getDocIdList(files);
        } catch (IOException ex) {
            Logger.getLogger(FederalistPapersGUI.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
    
    /**
     * Convert the document names into a more usable document id
     * @param files arraylist of string representing the file names
     * @return 
     */
    private ArrayList<Integer> getDocIdList(ArrayList<String> files) {
        ArrayList<String> allFiles = dindex.getFileNameList();
        ArrayList<Integer> docIDs = new ArrayList<>();
        
        for(int i = 0; i < files.size(); i++) {
            for(int j = 0; j < allFiles.size(); j++) {
                if(files.get(i).compareTo(allFiles.get(j)) == 0) {
                    docIDs.add(j);
                    break;
                }
            }
        }
        
        return docIDs;
    }
    
    /**
     * Create the document vectors by creating a hashmap of doc id and double[]
     * then looping through each term in the index and then loop through each
     * positional posting to create the vector
     */
    private void initializeDocumentVectors() {
        documentVectors = new HashMap<>(dindex.getDocumentCount());
        ArrayList<String> terms = dindex.getPositionalIndexTerms();
        
        for(int i = 0; i < terms.size(); i++) {
            ArrayList<PositionalPosting> postings = dindex.GetPostings(terms.get(i), true);
            
            for(PositionalPosting posting : postings) {
                double ld = dindex.getDocWeight(posting.getDocID());
                double[] wdts;
                
                if(documentVectors.containsKey(posting.getDocID())) {
                    wdts = documentVectors.get(posting.getDocID());
                }
                else {
                    wdts = new double[terms.size()];
                }
                
                double tftd = posting.getPositions().size();
                double wdt = 1 + Math.log(tftd);
                wdts[i] = wdt / ld;
                documentVectors.put(posting.getDocID(), wdts);
            }
        }
    }
    
    /**
     * Calculate the centroid of the class by adding all the document vectors
     * together then divide each value in the vector by the D_c value
     * @param files arraylist of integers representing the files in the class
     * @return 
     */
    private double[] calculateCentroid(ArrayList<Integer> files) {
        double[] results = documentVectors.get(files.get(0));
        double dc = files.size();

        for(int i = 1; i < files.size(); i++) {
            double[] docVec = documentVectors.get(files.get(i));
            
            for(int j = 0; j < results.length; j++) {
                results[j] += docVec[j];
            }
        }        
        
        for(int i = 0; i < results.length; i++) {
            results[i] = results[i] / dc;
        }
        
        return results;
    }
    
    /**
     * Subtract the class centroid with the document vector being passed in then
     * square the value, add it to the sum then take the square root
     * @param mCentroid the class centroid
     * @param doc the document vector of the disputed document
     * @return 
     */
    private double calculateClosestCentroid(double[] mCentroid, double[] doc) {
        double sum = 0.0;
        
        for(int i = 0; i < mCentroid.length; i++) {
            sum += Math.pow(mCentroid[i] - doc[i], 2);
        }
        
        return Math.sqrt(sum);
    }
    
    /**
     * Updates the table with the file list passed in and update the label
     * @param table the table to update
     * @param files arraylist of integers containing the files
     * @param label add the number of documents found
     */
    private void displayFiles(JTable table, ArrayList<Integer> files, JLabel label) {
        String columnNames[] = new String[] {"Papers"};
        DefaultTableModel model = (DefaultTableModel) table.getModel();
        model.setRowCount(0);
        model.setColumnCount(1);
        model.setColumnIdentifiers(columnNames);
        
        for(Integer file : files) {
            model.addRow(new Object[] {dindex.getFileNames(file)});
        }
        
        label.setText("Documents found: " + files.size());
    }
    
    private void getMutualInfoScores() {
        ArrayList<String> terms = dindex.getPositionalIndexTerms();
        jDocs.setItc(new double[terms.size()]);
        hDocs.setItc(new double[terms.size()]);
        mDocs.setItc(new double[terms.size()]);
        
        for(int i = 0; i < terms.size(); i++) {
            ArrayList<PositionalPosting> postings = dindex.GetPostings(terms.get(i), true);
            calculateMutualInfoScores(terms.get(i), postings, i);
        }
    }
    
    private void calculateMutualInfoScores(String term, 
            ArrayList<PositionalPosting> postings, int index) {
        int jN11 = 0, hN11 = 0, mN11 = 0;
        int jN01, hN01, mN01;
        int jN10, hN10, mN10;
        int jN00, hN00, mN00;
        
        for (PositionalPosting posting : postings) {
            if (hDocs.getFiles().contains(posting.getDocID())) {
                hN11++;
            } 
            else if (mDocs.getFiles().contains(posting.getDocID())) {
                mN11++;
            } 
            else if (jDocs.getFiles().contains(posting.getDocID())) {
                jN11++;
            }
        }

        jN01 = jDocs.getFiles().size() - jN11;
        mN01 = mDocs.getFiles().size() - mN11;
        hN01 = hDocs.getFiles().size() - hN11;

        jN10 = hN11 + mN11;
        hN10 = jN11 + mN11;
        mN10 = jN11 + hN11;

        jN00 = dindex.getDocumentCount() - jN11 - jN01 - jN10;
        hN00 = dindex.getDocumentCount() - hN11 - hN01 - hN10;
        mN00 = dindex.getDocumentCount() - mN11 - mN01 - mN10;
        


        double jItcScore = calculateItc((double) jN11, (double) jN01,
                (double) jN10, (double) jN00);
        double mItcScore = calculateItc((double) mN11, (double) mN01,
                (double) mN10, (double) mN00);
        double hItcScore = calculateItc((double) hN11, (double) hN01,
                (double) hN10, (double) hN00);

        double[] jItc = jDocs.getItc();
        jItc[index] = jItcScore;
        jDocs.setItc(jItc);
        double[] mItc = mDocs.getItc();
        mItc[index] = mItcScore;
        mDocs.setItc(mItc);
        double[] hItc = hDocs.getItc();
        hItc[index] = hItcScore;
        hDocs.setItc(hItc);
    }
    
    private double calculateItc(double N11, double N01, double N10, double N00) {
        double N = (double)dindex.getDocumentCount();
        double w, x, y, z;

        w = (N11/N)*(Math.log10((N*N11)/((N11+N10)*(N11+N01)))/Math.log10(2.0));

        if(Double.isNaN(w)) {
            w = 0.0;
        }
        
        x = (N01/N)*(Math.log10((N*N01)/((N01+N00)*(N11+N01)))/Math.log10(2.0));
        
        if(Double.isNaN(x)) {
            x = 0.0;
        }
        
        y = (N10/N)*(Math.log10((N*N10)/((N11+N10)*(N10+N00)))/Math.log10(2.0));
        
        if(Double.isNaN(y)) {
            y = 0.0;
        }
        
        z = (N00/N)*(Math.log10((N*N00)/((N01+N00)*(N10+N00)))/Math.log10(2));
        
        if(Double.isNaN(z)) {
            z = 0.0;
        }
        
        return w+x+y+z;
    }
    
    private void getEvidenceVector() {
        double[] jScores = jDocs.getItc();
        double[] mScores = mDocs.getItc();
        double[] hScores = hDocs.getItc();
        evidence = new double[dindex.getTermCount()];
        
        for(int i = 0; i < dindex.getTermCount(); i++) {
            if(mScores[i] > hScores[i]) {
                if(mScores[i] > jScores[i]) {
                    evidence[i] = mScores[i];
                }
            }
            else {
                if(hScores[i] > jScores[i]) {
                    evidence[i] = hScores[i];
                }
                else {
                    evidence[i] = jScores[i];
                }
            }
        }
    }
    
    private void selectEvidence() {
        evidenceTerms = new ArrayList<>();

        for(int i = 0; i < evidence.length; i++) {
            if(evidence[i] > 0.1) {
                evidenceTerms.add(dindex.getPositionalIndexTerms().get(i));
            }
        }
    }
    
    private void getFrequencyTerms() {
        disputedDocsTerms = new ArrayList<>();
        HashMap<String, Integer> hFtcMap = hDocs.getFtcMap();
        HashMap<String, Integer> mFtcMap = mDocs.getFtcMap();
        HashMap<String, Integer> jFtcMap = jDocs.getFtcMap();
        disputedDocsMap = new HashMap<>();
        int hFtcSum = 0;
        int mFtcSum = 0;
        int jFtcSum = 0;
        
        for(String term : evidenceTerms) {
            ArrayList<PositionalPosting> postings = dindex
                    .GetPostings(term, true);
            
            for (PositionalPosting posting : postings) {
                if (hDocs.getFiles().contains(posting.getDocID())) {
                    if (hFtcMap.containsKey(term)) {
                        int ftc = hFtcMap.get(term);
                        hFtcMap.put(term, ftc + posting.getPositions().size());
                    } else {
                        hFtcMap.put(term, posting.getPositions().size());
                    }

                    hFtcSum += posting.getPositions().size();
                }
                else if (mDocs.getFiles().contains(posting.getDocID())) {
                    if (mFtcMap.containsKey(term)) {
                        int ftc = mFtcMap.get(term);
                        mFtcMap.put(term, ftc + posting.getPositions().size());
                    } else {
                        mFtcMap.put(term, posting.getPositions().size());
                    }

                    mFtcSum += posting.getPositions().size();
                } 
                else if (jDocs.getFiles().contains(posting.getDocID())) {
                    if (jFtcMap.containsKey(term)) {
                        int ftc = jFtcMap.get(term);
                        jFtcMap.put(term, ftc + posting.getPositions().size());
                    } else {
                        jFtcMap.put(term, posting.getPositions().size());
                    }

                    jFtcSum += posting.getPositions().size();
                }
                else if(disputedDocs.contains(posting.getDocID())) {
                    if(!disputedDocsTerms.isEmpty()) {
                        if(disputedDocsTerms.get(disputedDocsTerms.size()-1)
                                .compareTo(term) != 0) {
                            disputedDocsTerms.add(term);
                        }
                    }
                    else {
                        disputedDocsTerms.add(term);
                    }
                    if(!disputedDocsMap.containsKey(posting.getDocID())) {
                        ArrayList<String> docTerms = new ArrayList<>();
                        docTerms.add(term);
                        disputedDocsMap.put(posting.getDocID(), docTerms);
                    }
                    else {
                        ArrayList<String> docTerms = disputedDocsMap
                                .get(posting.getDocID());
                        
                        if(!docTerms.contains(term)) {
                            docTerms.add(term);
                            disputedDocsMap.put(posting.getDocID(), docTerms);
                        }
                    }
                }
            }
        }
        
        jDocs.setFtcSum(jFtcSum);
        hDocs.setFtcSum(hFtcSum);
        mDocs.setFtcSum(mFtcSum);
        
        jDocs.setFtcMap(jFtcMap);
        hDocs.setFtcMap(hFtcMap);
        mDocs.setFtcMap(mFtcMap);
        
    }
    
    private void trainBayesianClassifier() {
        ArrayList<Double> ptch = new ArrayList<>();
        ArrayList<Double> ptcm = new ArrayList<>();
        ArrayList<Double> ptcj = new ArrayList<>();
        HashMap<String, Integer> hFtcMap = hDocs.getFtcMap();
        HashMap<String, Integer> jFtcMap = jDocs.getFtcMap();
        HashMap<String, Integer> mFtcMap = mDocs.getFtcMap();
        
        for(String term : evidenceTerms) {
            if(hFtcMap.containsKey(term)) {
                ptch.add((double)(hFtcMap.get(term) + 1)
                        /(double)(evidenceTerms.size() + hDocs.getFtcSum()));
            }
            else {
                ptch.add((double)(1)
                        /(double)(evidenceTerms.size() + hDocs.getFtcSum()));
            }
            if(mFtcMap.containsKey(term)) {
                ptcm.add((double)(mFtcMap.get(term) + 1)
                        /(double)(evidenceTerms.size() + mDocs.getFtcSum()));
            }
            else {
                ptcm.add((double)(1)
                        /(double)(evidenceTerms.size() + mDocs.getFtcSum()));
            }
            if(jFtcMap.containsKey(term)) {
                ptcj.add((double)(jFtcMap.get(term) + 1)
                        /(double)(evidenceTerms.size() + jDocs.getFtcSum()));
            }
            else {
                ptcj.add((double)(1)
                        /(double)(evidenceTerms.size() + jDocs.getFtcSum()));
            }
        }
        
        jDocs.setPtcj(ptcj);
        hDocs.setPtch(ptch);
        mDocs.setPtcm(ptcm);
    }
    
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(FederalistPapersGUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(FederalistPapersGUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(FederalistPapersGUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(FederalistPapersGUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new FederalistPapersGUI().setVisible(true);
            }
        });
    }
    
    private JayDocuments jDocs;
    private MadisonDocuments mDocs;
    private HamiltonDocuments hDocs;
    private ArrayList<Integer> disputedDocs;
    private ArrayList<String> disputedDocsTerms;
    private HashMap<Integer, ArrayList<String>> disputedDocsMap;
    private DiskInvertedIndex dindex;
    private HashMap<Integer, double[]> documentVectors;
    private double[] evidence;
    private ArrayList<String> evidenceTerms;
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton bayesianButton;
    private javax.swing.JFileChooser directoryChooser;
    private javax.swing.JMenu fileMenu;
    private javax.swing.JMenuBar fileMenuBar;
    private javax.swing.JLabel hamiltonFileLabel;
    private javax.swing.JLabel hamiltonLabel;
    private javax.swing.JPanel hamiltonPanel;
    private javax.swing.JScrollPane hamiltonScrollPane;
    private javax.swing.JTable hamiltonTable;
    private javax.swing.JLabel jayFileLabel;
    private javax.swing.JLabel jayLabel;
    private javax.swing.JPanel jayPanel;
    private javax.swing.JScrollPane jayScrollPane;
    private javax.swing.JTable jayTable;
    private javax.swing.JLabel madisonFileLabel;
    private javax.swing.JLabel madisonLabel;
    private javax.swing.JPanel madisonPanel;
    private javax.swing.JScrollPane madisonScrollPane;
    private javax.swing.JTable madisonTable;
    private javax.swing.JPanel mainPanel;
    private javax.swing.JMenuItem openExistingMenuItem;
    private javax.swing.JMenuItem openMenuItem;
    private javax.swing.JButton rocchioButton;
    // End of variables declaration//GEN-END:variables
}
